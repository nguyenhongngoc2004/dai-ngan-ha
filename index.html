<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Galaxy + Solar System</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>

<body style="margin:0; overflow:hidden; background:black;">
<video id="video" style="display:none;"></video>
<canvas id="handCanvas" width="640" height="480"
        style="position:absolute; top:0; left:0;"></canvas>

<script>
// ================= THREE.JS =================
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.z = 60;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.8));

// ================= GALAXY =================
const galaxy = new THREE.Group();
scene.add(galaxy);

// Sun
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(6, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0xffff00,
    transparent: true,
    blending: THREE.AdditiveBlending
  })
);
galaxy.add(sun);

// ================= PLANETS =================
const planets = [];

function createPlanet(radius, dist, speed, color) {
  const pivot = new THREE.Object3D();

  const planet = new THREE.Mesh(
    new THREE.SphereGeometry(radius, 24, 24),
    new THREE.MeshStandardMaterial({
      color,
      emissive: color,
      emissiveIntensity: 0.25
    })
  );

  planet.position.x = dist;
  pivot.userData.speed = speed;

  pivot.add(planet);
  galaxy.add(pivot);
  planets.push(pivot);
}

createPlanet(1,   10, 0.02, 0xaaaaaa);
createPlanet(1.2, 14, 0.018, 0xffaa00);
createPlanet(1.3, 18, 0.016, 0x2266ff);
createPlanet(1.1, 22, 0.014, 0xff0000);
createPlanet(2.5, 30, 0.01,  0xff8800);
createPlanet(2,   38, 0.008, 0xffddaa);
createPlanet(1.5, 46, 0.006, 0x00ffff);
createPlanet(1.4, 52, 0.004, 0x000088);

// ================= STAR DUST =================
(function createStars(){
  const count = 6000;
  const pos = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    const r = Math.random() * 80;
    const a = r * 0.35;
    pos[i*3]   = Math.cos(a) * r;
    pos[i*3+1] = (Math.random() - 0.5) * 15;
    pos[i*3+2] = Math.sin(a) * r;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  const mat = new THREE.PointsMaterial({
    size: 1,
    color: 0xffffff,
    opacity: 0.6,
    transparent: true,
    blending: THREE.AdditiveBlending
  });

  scene.add(new THREE.Points(geo, mat));
})();

// ================= HAND TRACKING =================
const videoEl = document.getElementById("video");
const canvasEl = document.getElementById("handCanvas");
const ctx = canvasEl.getContext("2d");

let state = "ROTATE"; // ROTATE | PHOTO | HEART | TREE

const hands = new Hands({
  locateFile: file =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(results => {
  ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

  if (results.image) {
    ctx.drawImage(results.image, 0, 0, canvasEl.width, canvasEl.height);
  }

  if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
    state = "TREE";
    return;
  }

  // ❤️ Two-hand heart
  if (results.multiHandLandmarks.length === 2) {
    const h1 = results.multiHandLandmarks[0];
    const h2 = results.multiHandLandmarks[1];

    const dIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
    const dThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);

    if (dIndex < 0.15 && dThumb < 0.15) {
      state = "HEART";
      return;
    }
  }

  // ✋ One-hand gestures
  const lm = results.multiHandLandmarks[0];
  const wrist = lm[0];
  const tips = [8,12,16,20];

  let open = 0;
  tips.forEach(i => {
    open += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y);
  });

  const avgOpen = open / tips.length;
  const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

  if (pinch < 0.05) state = "PHOTO";
  else if (avgOpen < 0.25) state = "TREE";
  else state = "ROTATE";
});

// Camera
const cam = new Camera(videoEl, {
  onFrame: async () => await hands.send({ image: videoEl }),
  width: 640,
  height: 480
});
cam.start();

// ================= ANIMATE =================
function animate() {
  requestAnimationFrame(animate);

  sun.rotation.y += 0.003;

  planets.forEach(p => {
    p.rotation.y += p.userData.speed;

    const scale = state === "PHOTO" ? 3 : 1;
    p.children[0].scale.lerp(
      new THREE.Vector3(scale, scale, scale), 0.1
    );
  });

  if (state === "ROTATE") galaxy.rotation.y += 0.003;
  if (state === "HEART") galaxy.scale.lerp(new THREE.Vector3(1.4,1.4,1.4),0.05);
  else galaxy.scale.lerp(new THREE.Vector3(1,1,1),0.05);

  renderer.render(scene, camera);
}
animate();

// ================= RESIZE =================
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
