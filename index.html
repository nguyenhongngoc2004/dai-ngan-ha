<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Hyper-Real Galaxy</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<style>
body { margin:0; overflow:hidden; background:black; }
#gestureNote {
  position:absolute; bottom:20px; left:20px;
  padding:10px 14px; background:rgba(0,0,0,0.45);
  color:#fff; font-family:system-ui,-apple-system,BlinkMacSystemFont;
  font-size:14px; border-radius:12px;
  backdrop-filter:blur(6px); pointer-events:none;
  box-shadow:0 0 12px rgba(255,255,255,0.15);
}
#handCanvas {
  position:absolute;
  bottom:20px;
  right:20px;
  width:160px;      /* hi·ªÉn th·ªã nh·ªè h∆°n */
  height:120px;
  border-radius:12px;
  opacity:0.75;
  pointer-events:none;
  z-index:10;
}
</style>
</head>
<body>
<div id="gestureNote"></div>
<video id="video" style="display:none;"></video>
<canvas id="handCanvas" width="160" height="120"></canvas>

<script>
// ================= THREE.JS =================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 250, 400);
camera.lookAt(0,0,0);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff,0.25));

const galaxy = new THREE.Group();
scene.add(galaxy);

const sunLight = new THREE.PointLight(0xfff2cc,2.5,400);
sunLight.position.set(0,0,0);
galaxy.add(sunLight);

// Sun with glow
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(6,64,64),
  new THREE.MeshPhysicalMaterial({
    color:0xffee88,
    emissive:0xffcc66,
    emissiveIntensity:1.5,
    roughness:0.4
  })
);
galaxy.add(sun);

// ================= PLANETS =================
const planets = [];

function createPlanet(radius, dist, speed, options={}){
  const pivot = new THREE.Object3D();
  pivot.userData.speed = speed;

  const mat = new THREE.MeshPhysicalMaterial({
    color: options.color ?? 0xffffff,
    roughness: options.roughness ?? 0.5,
    metalness: options.metalness ?? 0.1,
    emissive: options.emissive ?? 0x000000,
    emissiveIntensity: options.emissiveIntensity ?? 0.05,
    clearcoat: options.clearcoat ?? 0.2
  });

  const planet = new THREE.Mesh(new THREE.SphereGeometry(radius,64,64), mat);
  planet.position.x = dist;
  pivot.userData.planet = planet;
  pivot.add(planet);

  // Atmosphere
  if(options.atmosphere){
    const atmo = new THREE.Mesh(
      new THREE.SphereGeometry(radius*1.05,64,64),
      new THREE.MeshBasicMaterial({
        color: options.atmosphere,
        transparent:true,
        opacity:0.15,
        blending:THREE.AdditiveBlending
      })
    );
    planet.add(atmo);
    pivot.userData.atmo = atmo;
  }

  // Ring
  if(options.ring){
    const ring = new THREE.Mesh(
      new THREE.RingGeometry(radius*1.4, radius*2.2,64),
      new THREE.MeshBasicMaterial({
        color:options.ring,
        transparent:true,
        opacity:0.5,
        side:THREE.DoubleSide
      })
    );
    ring.rotation.x = Math.PI/2;
    planet.add(ring);
  }

  galaxy.add(pivot);
  planets.push(pivot);
  return pivot;
}

createPlanet(1.5, 10, 0.02, {color:0xaaaaaa});
createPlanet(2, 15, 0.018, {color:0xffcc88});
createPlanet(2.5, 20, 0.016, {color:0x2266ff, atmosphere:0x66ccff});
createPlanet(2, 25, 0.014, {color:0xff5533});
createPlanet(3, 30, 0.01, {color:0xffaa55});
createPlanet(2.5, 35, 0.008, {color:0xffe0aa, ring:0xffddaa});
createPlanet(2, 40, 0.006, {color:0x88ccff, emissive:0x2244ff, emissiveIntensity:0.1});

// üåü Kh·ªüi t·∫°o h√†nh tinh hi·ªán t·∫°i
let currentPlanetIndex = 0;

// ================= STAR DUST =================
(function createStars(){
  const count = 8000;
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r=Math.random()*120;
    const a=r*0.35;
    pos[i*3]=Math.cos(a)*r;
    pos[i*3+1]=(Math.random()-0.5)*20;
    pos[i*3+2]=Math.sin(a)*r;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));

  const mat=new THREE.PointsMaterial({
    size:1.2,                     // tƒÉng size n·∫øu mu·ªën
    map: createStarTexture(),      // d√πng texture tr√≤n m·ªãn
    transparent:true,
    opacity:0.6,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    sizeAttenuation:true
  });

  scene.add(new THREE.Points(geo,mat));
})();

function createStarTexture() {
    const size = 128;
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext("2d");

    const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    grad.addColorStop(0,"rgba(255,255,255,1)");
    grad.addColorStop(0.4,"rgba(255,255,255,0.6)");
    grad.addColorStop(1,"rgba(255,255,255,0)");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,size,size);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter; // m·ªãn h∆°n
    texture.magFilter = THREE.LinearFilter;
    return texture;
}

// Sau ƒë√≥:
const mat=new THREE.PointsMaterial({
    size:1.2,
    map: createStarTexture(),
    transparent:true,
    opacity:0.6,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    sizeAttenuation:true
});

function createMilkyWay(){
  const starCount=30000,positions=[],colors=[];
  const arms = 4, radius = 200, thickness = 0.3;
  for(let i=0;i<starCount;i++){
    const r=Math.random()*radius;
    const arm=i%arms;
    const angle=r*0.07+arm*(Math.PI*2/arms);
    const spread=1.5;
    const x=Math.cos(angle)*r+(Math.random()-0.5)*spread;
    const z=Math.sin(angle)*r+(Math.random()-0.5)*spread;
    const y=(Math.random()-0.5)*thickness;
    positions.push(x,y,z);
    const t=r/radius;
    const c=new THREE.Color();
    c.r=1*(1-t)+0.5*t; c.g=0.85*(1-t)+0.8*t; c.b=0.5*(1-t)+1*t;
    colors.push(c.r,c.g,c.b);
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));
  geo.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));
const mat = new THREE.PointsMaterial({
  size: 0.2,                  // to h∆°n
  map: createStarTexture(),    // v·∫´n d√πng gradient tr√≤n
  transparent: true,
  opacity: 0.9,
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  sizeAttenuation: true        // k√≠ch th∆∞·ªõc thay ƒë·ªïi theo camera
});
  const milkyWay=new THREE.Points(geo,mat);
  galaxy.add(milkyWay);
}
createMilkyWay();

// ================= HAND TRACKING =================
const videoEl=document.getElementById("video");
const canvasEl=document.getElementById("handCanvas");
const ctx2=canvasEl.getContext("2d");
let state="ROTATE",smoothState="ROTATE";
const noteEl=document.getElementById("gestureNote");
const stateText={ROTATE:"‚úã Xoay tay: Xoay d·∫£i ng√¢n h√†",PHOTO:"üëå Ch·ª•m tay: Ph√≥ng to h√†nh tinh",HEART:"‚ù§Ô∏è Hai tay h√¨nh tim: K√≠ch ho·∫°t nƒÉng l∆∞·ª£ng",TREE:"‚úä N·∫Øm tay: Thu nh·ªè h·ªá sao"};

const hands=new Hands({locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.7,minTrackingConfidence:0.7});

let initialLoad = true;

hands.onResults(results => {
  // v·∫Ω video l√™n canvas g√≥c
  ctx2.save();
  ctx2.clearRect(0,0,canvasEl.width,canvasEl.height);
  if(results.image) ctx2.drawImage(results.image,0,0,canvasEl.width,canvasEl.height);
  ctx2.restore();

  if(!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

  const lm = results.multiHandLandmarks[0];
  const wrist = lm[0];
  const tips = [8,12,16,20];

  // t√≠nh ƒë·ªô m·ªü tay
  let open = 0;
  tips.forEach(i => open += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
  const avgOpen = open / tips.length;

  // t√≠nh kho·∫£ng c√°ch ng√≥n c√°i-ch·ªâ
  const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

  // ‚ë† ∆∞u ti√™n pinch ‚Üí zoom v√†o h√†nh tinh
  if(pinch < 0.06){
    state = "PHOTO";
    moveToPlanet(currentPlanetIndex);
  } 
  // ‚ë° bung tay ‚Üí xoay to√†n c·∫£nh
  else if(avgOpen > 0.25){
    state = "ROTATE";
  } 
  // ‚ë¢ n·∫Øm tay ‚Üí zoom ra to√†n c·∫£nh
  else{
    state = "TREE";
  }
});

function moveToPlanet(index){
  if(index<0) index=planets.length-1;
  if(index>=planets.length) index=0;
  currentPlanetIndex=index;

  const planetPos = new THREE.Vector3();
  planets[currentPlanetIndex].userData.planet.getWorldPosition(planetPos);

  targetCameraPos.copy(planetPos);
  targetCameraPos.add(new THREE.Vector3(0,6,14)); // offset camera
}

const cameraMP=new Camera(videoEl,{onFrame:async()=>{await hands.send({image:videoEl});},width:640,height:480});
cameraMP.start();

// ================= ANIMATE =================

// Camera l√∫c load ‚Üí nh√¨n to√†n c·∫£nh d·∫£i ng√¢n h√†
const initialCameraPos = new THREE.Vector3(0, 50, 150);
camera.position.copy(initialCameraPos);

// LookAt trung t√¢m d·∫£i ng√¢n h√†
const lookTarget = new THREE.Vector3(0,0,0);
camera.lookAt(lookTarget);

// targetCameraPos l√∫c load tr√πng v·ªõi initialCameraPos
let targetCameraPos = initialCameraPos.clone();


function animate(){
  requestAnimationFrame(animate);

  sun.rotation.y += 0.003;

  planets.forEach(p=>{
    p.rotation.y += p.userData.speed;
    const targetScale = state==="PHOTO"?3:1;
    p.scale.lerp(new THREE.Vector3(targetScale,targetScale,targetScale),0.1);
  });

  // Camera logic
  if(state==="PHOTO"){
    planets[currentPlanetIndex].userData.planet.getWorldPosition(lookTarget);
    camera.position.lerp(targetCameraPos,0.05);
  } else { 
    camera.position.lerp(initialCameraPos,0.05);
  }

  camera.lookAt(lookTarget);

  smoothState = state;
  if(smoothState==="HEART") galaxy.scale.lerp(new THREE.Vector3(1.4,1.4,1.4),0.05);
  else galaxy.scale.lerp(new THREE.Vector3(1,1,1),0.05);

  noteEl.textContent = stateText[smoothState] || "";

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>