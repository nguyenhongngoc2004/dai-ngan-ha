<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Universe ‚Äì 7 Orbits</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(#1a001f, #000000);
  }
  #hint {
    position: fixed;
    bottom: 16px;
    left: 16px;
    color: #fff;
    font-family: system-ui;
    font-size: 14px;
    opacity: 0.6;
  }
</style>
</head>

<body>
<div id="hint">üñ± Drag: Rotate ¬∑ Scroll: Zoom</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.152.2/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js";

/// ================= SCENE =================
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  500
);
camera.position.set(0, 10, 32);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

/// ================= CONTROLS =================
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.dampingFactor = 0.06;
controls.minDistance = 10;
controls.maxDistance = 80;

/// ================= LIGHT =================
scene.add(new THREE.AmbientLight(0x222222));

const centerLight = new THREE.PointLight(0xffffff, 2.5, 300);
centerLight.position.set(0, 0, 0);
scene.add(centerLight);

/// ================= GROUP =================
const solar = new THREE.Group();
scene.add(solar);

/// ================= OPTIONAL CENTER (small sun) =================
// Xo√° ƒëo·∫°n n√†y n·∫øu mu·ªën TR·ªêNG ho√†n to√†n ·ªü gi·ªØa
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(1.2, 32, 32),
  new THREE.MeshStandardMaterial({
    emissive: 0xffcc66,
    emissiveIntensity: 1.2,
    color: 0xffee99
  })
);
solar.add(sun);

/// ================= STARS BACKGROUND =================
const starGeo = new THREE.BufferGeometry();
const starPos = [];

for (let i = 0; i < 6000; i++) {
  starPos.push(
    (Math.random() - 0.5) * 400,
    (Math.random() - 0.5) * 400,
    (Math.random() - 0.5) * 400
  );
}

starGeo.setAttribute(
  "position",
  new THREE.Float32BufferAttribute(starPos, 3)
);

const stars = new THREE.Points(
  starGeo,
  new THREE.PointsMaterial({
    size: 0.35,
    color: 0xffffff,
    transparent: true,
    opacity: 0.7
  })
);
scene.add(stars);

/// ================= HELPERS =================
const planets = [];

function createOrbit(radius) {
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(radius - 0.04, radius + 0.04, 128),
    new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.35,
      side: THREE.DoubleSide
    })
  );
  ring.rotation.x = Math.PI / 2;
  solar.add(ring);
}

function addPlanet(size, distance, speed, color) {
  createOrbit(distance);

  const pivot = new THREE.Object3D();

  const planet = new THREE.Mesh(
    new THREE.SphereGeometry(size, 32, 32),
    new THREE.MeshStandardMaterial({
      color,
      roughness: 0.85,
      metalness: 0.05
    })
  );

  planet.position.x = distance;
  pivot.add(planet);
  pivot.userData.speed = speed;

  solar.add(pivot);
  planets.push(pivot);
}

/// ================= 7 PLANETS ‚Äì 7 ORBITS =================
addPlanet(0.45, 4,   0.030, 0xaaaaaa); // Mercury
addPlanet(0.65, 6,   0.024, 0xffcc88); // Venus
addPlanet(0.75, 8,   0.020, 0x2a5cff); // Earth
addPlanet(0.65, 10,  0.018, 0xff5533); // Mars
addPlanet(1.15, 14,  0.012, 0xffaa55); // Jupiter
addPlanet(0.95, 18,  0.010, 0xffe0aa); // Saturn
addPlanet(0.85, 22,  0.008, 0x88ccff); // Uranus

/// ================= ANIMATE =================
function animate() {
  requestAnimationFrame(animate);

  planets.forEach(p => {
    p.rotation.y += p.userData.speed;
  });

  controls.update();
  renderer.render(scene, camera);
}
animate();

/// ================= RESIZE =================
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>