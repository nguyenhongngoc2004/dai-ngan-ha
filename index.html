<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Hyper-Real Galaxy</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/simplex-noise.min.js"></script>
<style>
body { margin:0; overflow:hidden; background:black; }
#gestureNote {
  position:absolute; bottom:20px; left:20px;
  padding:10px 14px; background:rgba(0,0,0,0.45);
  color:#fff; font-family:system-ui,-apple-system,BlinkMacSystemFont;
  font-size:14px; border-radius:12px;
  backdrop-filter:blur(6px); pointer-events:none;
  box-shadow:0 0 12px rgba(255,255,255,0.15);
}
#handCanvas {
  position:absolute;
  bottom:20px;
  right:20px;
  width:160px;      /* hi·ªÉn th·ªã nh·ªè h∆°n */
  height:120px;
  border-radius:12px;
  opacity:0.75;
  pointer-events:none;
  z-index:10;
}
</style>
</head>
<body>
<div id="gestureNote"></div>
<video id="video" style="display:none;"></video>
<canvas id="handCanvas" width="160" height="120"></canvas>

<script>

let lastState = "ROTATE";
// ================= THREE.JS =================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 250, 400);
camera.lookAt(0,0,0);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff,0.25));

const galaxy = new THREE.Group();
scene.add(galaxy);

const sunLight = new THREE.PointLight(0xfff2cc,2.5,400);
sunLight.position.set(0,0,0);
galaxy.add(sunLight);

// Sun with glow
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(6,64,64),
  new THREE.MeshPhysicalMaterial({
    color:0xffee88,
    emissive:0xffcc66,
    emissiveIntensity:1.5,
    roughness:0.4
  })
);
galaxy.add(sun);

// ================= Planets Realistic v·ªõi ƒë·∫∑c tr∆∞ng =================
const planets = [];
const noise = new SimplexNoise(); // SimplexNoise cho b·ªÅ m·∫∑t l·ªìi l√µm

function createPlanetRealistic(radius, dist, speed, options = {}) {
  const pivot = new THREE.Object3D();
  pivot.userData.speed = speed;

  // Geometry nhi·ªÅu segments ƒë·ªÉ displacement m∆∞·ª£t
  const geo = new THREE.SphereGeometry(radius, 128, 128);

  // Vertex displacement theo Simplex noise
  for (let i = 0; i < geo.attributes.position.count; i++) {
    const v = new THREE.Vector3().fromBufferAttribute(geo.attributes.position, i);
    const n = noise.noise3D(
      v.x * (options.noiseScale ?? 0.5),
      v.y * (options.noiseScale ?? 0.5),
      v.z * (options.noiseScale ?? 0.5)
    );
    const offset = n * (options.displacementScale ?? 0.5);
    v.multiplyScalar(1 + offset);
    geo.attributes.position.setXYZ(i, v.x, v.y, v.z);
  }
  geo.computeVertexNormals();

  const mat = new THREE.MeshPhysicalMaterial({
    color: options.color ?? 0xaaaaaa,
    roughness: options.roughness ?? 0.7,
    metalness: options.metalness ?? 0,
    clearcoat: options.clearcoat ?? 0.2,
    clearcoatRoughness: options.clearcoatRoughness ?? 0.1,
  });

  const planet = new THREE.Mesh(geo, mat);
  planet.position.x = dist;
  pivot.userData.planet = planet;
  pivot.add(planet);

  // Glow nh·∫π xung quanh h√†nh tinh
  if (options.atmosphere) {
    const glowMat = new THREE.MeshBasicMaterial({
      color: options.atmosphere,
      transparent: true,
      opacity: 0.15,
      blending: THREE.AdditiveBlending,
    });
    const glow = new THREE.Mesh(
      new THREE.SphereGeometry(radius * 1.05, 64, 64),
      glowMat
    );
    planet.add(glow);
    pivot.userData.atmo = glow;
  }

  galaxy.add(pivot);
  planets.push(pivot);
  return pivot;
}

// üåç T·∫°o h√†nh tinh v·ªõi ƒë·∫∑c tr∆∞ng ri√™ng
createPlanetRealistic(1.5, 10, 0.02, { color: 0xaaaaaa, displacementScale: 0.2, noiseScale: 1.0 }); // h√†nh tinh ƒë√° tr∆°n
createPlanetRealistic(2, 15, 0.018, { color: 0xffcc88, displacementScale: 0.4, noiseScale: 0.8 }); // h√†nh tinh c√°t / sa m·∫°c
createPlanetRealistic(2.5, 20, 0.016, { color: 0x2266ff, atmosphere: 0x66ccff, displacementScale: 0.35, noiseScale: 0.7 }); // h√†nh tinh n∆∞·ªõc + kh√≠ quy·ªÉn
createPlanetRealistic(2, 25, 0.014, { color: 0xff5533, displacementScale: 0.5, noiseScale: 0.6 }); // h√†nh tinh n√∫i l·ª≠a
createPlanetRealistic(3, 30, 0.01, { color: 0xffaa55, displacementScale: 0.25, noiseScale: 1.2 }); // h√†nh tinh ƒë√° nh·∫π, nh·∫µn
createPlanetRealistic(2.5, 35, 0.008, { color: 0xffe0aa, displacementScale: 0.3, noiseScale: 0.9, ring: 0xffddaa }); // h√†nh tinh c√≥ v√†nh
createPlanetRealistic(2, 40, 0.006, { color: 0x88ccff, emissive: 0x2244ff, emissiveIntensity: 0.1, displacementScale: 0.45, noiseScale: 0.7 }); // h√†nh tinh bƒÉng / bƒÉng √°nh s√°ng

// üåü Kh·ªüi t·∫°o h√†nh tinh hi·ªán t·∫°i
let currentPlanetIndex = 0;

// ================= STAR DUST =================
(function createStars(){
  const count = 8000;
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r=Math.random()*120;
    const a=r*0.35;
    pos[i*3]=Math.cos(a)*r;
    pos[i*3+1]=(Math.random()-0.5)*20;
    pos[i*3+2]=Math.sin(a)*r;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));

  const mat=new THREE.PointsMaterial({
    size:1.2,                     // tƒÉng size n·∫øu mu·ªën
    map: createStarTexture(),      // d√πng texture tr√≤n m·ªãn
    transparent:true,
    opacity:0.6,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    sizeAttenuation:true
  });

  scene.add(new THREE.Points(geo,mat));
})();

function createStarTexture() {
    const size = 128;
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext("2d");

    const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    grad.addColorStop(0,"rgba(255,255,255,1)");
    grad.addColorStop(0.4,"rgba(255,255,255,0.6)");
    grad.addColorStop(1,"rgba(255,255,255,0)");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,size,size);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter; // m·ªãn h∆°n
    texture.magFilter = THREE.LinearFilter;
    return texture;
}

// Sau ƒë√≥:
const mat=new THREE.PointsMaterial({
    size:1.2,
    map: createStarTexture(),
    transparent:true,
    opacity:0.6,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    sizeAttenuation:true
});

function createMilkyWay(){
  const starCount=30000,positions=[],colors=[];
  const arms = 4, radius = 200, thickness = 0.3;
  for(let i=0;i<starCount;i++){
    const r=Math.random()*radius;
    const arm=i%arms;
    const angle=r*0.07+arm*(Math.PI*2/arms);
    const spread=1.5;
    const x=Math.cos(angle)*r+(Math.random()-0.5)*spread;
    const z=Math.sin(angle)*r+(Math.random()-0.5)*spread;
    const y=(Math.random()-0.5)*thickness;
    positions.push(x,y,z);
    const t=r/radius;
    const c=new THREE.Color();
    c.r=1*(1-t)+0.5*t; c.g=0.85*(1-t)+0.8*t; c.b=0.5*(1-t)+1*t;
    colors.push(c.r,c.g,c.b);
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));
  geo.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));
const mat = new THREE.PointsMaterial({
  size: 0.2,                  // to h∆°n
  map: createStarTexture(),    // v·∫´n d√πng gradient tr√≤n
  transparent: true,
  opacity: 0.9,
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  sizeAttenuation: true        // k√≠ch th∆∞·ªõc thay ƒë·ªïi theo camera
});
  const milkyWay=new THREE.Points(geo,mat);
  galaxy.add(milkyWay);
}
createMilkyWay();

// ================= HAND TRACKING =================
const videoEl=document.getElementById("video");
const canvasEl=document.getElementById("handCanvas");
const ctx2=canvasEl.getContext("2d");
let state="ROTATE",smoothState="ROTATE";
const noteEl=document.getElementById("gestureNote");
const stateText={
  ROTATE:"‚úã Xoay tay: Chuy·ªÉn h√†nh tinh",  // tay m·ªü v·ª´a ‚Üí chuy·ªÉn h√†nh tinh
  TREE:"‚úä Bung tay: Zoom ra to√†n c·∫£nh",    // bung tay ‚Üí zoom ra
  PHOTO:"ü§è N·∫Øm tay: Zoom v√†o h√†nh tinh"  // n·∫Øm tay ‚Üí zoom v√†o
};

const hands=new Hands({locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.7,minTrackingConfidence:0.7});

let initialLoad = true;

hands.onResults(results => {
  // v·∫Ω video l√™n canvas g√≥c
  ctx2.save();
  ctx2.clearRect(0,0,canvasEl.width,canvasEl.height);
  if(results.image) ctx2.drawImage(results.image,0,0,canvasEl.width,canvasEl.height);
  ctx2.restore();

  if(!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

  const lm = results.multiHandLandmarks[0];
  const wrist = lm[0];
  const tips = [8,12,16,20];

  let open = 0;
  tips.forEach(i => open += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
  const avgOpen = open / tips.length;

  let newState = lastState;

  if(avgOpen < 0.18) newState = "PHOTO";    // n·∫Øm tay
  else if(avgOpen > 0.28) newState = "TREE"; // bung tay
  else newState = "ROTATE";                 // m·ªü tay v·ª´a ph·∫£i

  // ch·ªâ update state khi thay ƒë·ªïi ƒë·ªÉ tr√°nh nh·∫£y nhi·ªÅu l·∫ßn/frame
  if(newState !== lastState){
    if(newState === "ROTATE" && lastState !== "ROTATE"){
      // m·ªói l·∫ßn v√†o ROTATE t·ª´ tr·∫°ng th√°i kh√°c ‚Üí chuy·ªÉn h√†nh tinh
      currentPlanetIndex++;
      if(currentPlanetIndex >= planets.length) currentPlanetIndex = 0;
      moveToPlanet(currentPlanetIndex);
    }

    state = newState;
    lastState = newState;
  }
});

function moveToPlanet(index){
  if(index<0) index=planets.length-1;
  if(index>=planets.length) index=0;
  currentPlanetIndex=index;

  const planetPos = new THREE.Vector3();
  planets[currentPlanetIndex].userData.planet.getWorldPosition(planetPos);

  targetCameraPos.copy(planetPos);
  targetCameraPos.add(new THREE.Vector3(0,6,14)); // offset camera
}

const cameraMP=new Camera(videoEl,{onFrame:async()=>{await hands.send({image:videoEl});},width:640,height:480});
cameraMP.start();

// ================= ANIMATE =================

// Camera l√∫c load ‚Üí nh√¨n to√†n c·∫£nh d·∫£i ng√¢n h√†
const initialCameraPos = new THREE.Vector3(0, 50, 150);
camera.position.copy(initialCameraPos);

// LookAt trung t√¢m d·∫£i ng√¢n h√†
const lookTarget = new THREE.Vector3(0,0,0);
camera.lookAt(lookTarget);

// targetCameraPos l√∫c load tr√πng v·ªõi initialCameraPos
let targetCameraPos = initialCameraPos.clone();


function animate(){
  requestAnimationFrame(animate);

  sun.rotation.y += 0.003;

  planets.forEach(p=>{
    p.rotation.y += p.userData.speed;
    const targetScale = state==="PHOTO"?3:1;
    p.scale.lerp(new THREE.Vector3(targetScale,targetScale,targetScale),0.1);
  });

  // Camera logic
  if(state==="PHOTO"){
    planets[currentPlanetIndex].userData.planet.getWorldPosition(lookTarget);
    camera.position.lerp(targetCameraPos,0.05);
  } else { 
    camera.position.lerp(initialCameraPos,0.05);
  }

  camera.lookAt(lookTarget);

  smoothState = state;
  if(smoothState==="HEART") galaxy.scale.lerp(new THREE.Vector3(1.4,1.4,1.4),0.05);
  else galaxy.scale.lerp(new THREE.Vector3(1,1,1),0.05);

  noteEl.textContent = stateText[smoothState] || "";

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>