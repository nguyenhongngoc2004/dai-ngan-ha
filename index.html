<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Hyper-Real Galaxy</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<style>
body { margin:0; overflow:hidden; background:black; }
#gestureNote {
  position:absolute; bottom:20px; left:20px;
  padding:10px 14px; background:rgba(0,0,0,0.45);
  color:#fff; font-family:system-ui,-apple-system,BlinkMacSystemFont;
  font-size:14px; border-radius:12px;
  backdrop-filter:blur(6px); pointer-events:none;
  box-shadow:0 0 12px rgba(255,255,255,0.15);
}
#handCanvas {
  position:absolute;
  bottom:20px;
  right:20px;
  transform: scale(0.5);
  transform-origin: bottom right;
  border-radius:12px;
  opacity:0.75;
  pointer-events:none;
  z-index:10;
}

</style>
</head>
<body>
<div id="gestureNote"></div>
<video id="video" style="display:none;"></video>
<canvas id="handCanvas" width="320" height="240"></canvas>

<script>
// ================= THREE.JS =================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 120, 250); 
camera.lookAt(0, 0, 0);
targetCameraPos.copy(camera.position);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff,0.25));

const galaxy = new THREE.Group();
scene.add(galaxy);

const sunLight = new THREE.PointLight(0xfff2cc,2.5,400);
sunLight.position.set(0,0,0);
galaxy.add(sunLight);

// Sun with glow
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(6,64,64),
  new THREE.MeshPhysicalMaterial({
    color:0xffee88,
    emissive:0xffcc66,
    emissiveIntensity:1.5,
    roughness:0.4
  })
);
galaxy.add(sun);

// ================= PLANETS =================
const planets = [];

function createPlanet(radius, dist, speed, options={}){
  const pivot = new THREE.Object3D();
  pivot.userData.speed = speed;

  const mat = new THREE.MeshPhysicalMaterial({
    color: options.color ?? 0xffffff,
    roughness: options.roughness ?? 0.5,
    metalness: options.metalness ?? 0.1,
    emissive: options.emissive ?? 0x000000,
    emissiveIntensity: options.emissiveIntensity ?? 0.05,
    clearcoat: options.clearcoat ?? 0.2
  });

  const planet = new THREE.Mesh(new THREE.SphereGeometry(radius,64,64), mat);
  planet.position.x = dist;
  pivot.userData.planet = planet;
  pivot.add(planet);

  // Atmosphere
  if(options.atmosphere){
    const atmo = new THREE.Mesh(
      new THREE.SphereGeometry(radius*1.05,64,64),
      new THREE.MeshBasicMaterial({
        color: options.atmosphere,
        transparent:true,
        opacity:0.15,
        blending:THREE.AdditiveBlending
      })
    );
    planet.add(atmo);
    pivot.userData.atmo = atmo;
  }

  // Ring
  if(options.ring){
    const ring = new THREE.Mesh(
      new THREE.RingGeometry(radius*1.4, radius*2.2,64),
      new THREE.MeshBasicMaterial({
        color:options.ring,
        transparent:true,
        opacity:0.5,
        side:THREE.DoubleSide
      })
    );
    ring.rotation.x = Math.PI/2;
    planet.add(ring);
  }

  galaxy.add(pivot);
  planets.push(pivot);
  return pivot;
}

// Create planets
createPlanet(1,10,0.02,{color:0xaaaaaa});
createPlanet(1.2,14,0.018,{color:0xffcc88});
createPlanet(1.3,18,0.016,{color:0x2266ff,atmosphere:0x66ccff});
createPlanet(1.1,22,0.014,{color:0xff5533});
createPlanet(2.5,30,0.01,{color:0xffaa55});
createPlanet(2,38,0.008,{color:0xffe0aa,ring:0xffddaa});
createPlanet(1.5,46,0.006,{color:0x88ccff,emissive:0x2244ff,emissiveIntensity:0.1});

// ================= STAR DUST =================
(function createStars(){
  const count = 8000;
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r=Math.random()*120;
    const a=r*0.35;
    pos[i*3]=Math.cos(a)*r;
    pos[i*3+1]=(Math.random()-0.5)*20;
    pos[i*3+2]=Math.sin(a)*r;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  const mat=new THREE.PointsMaterial({size:1,color:0xffffff,opacity:0.6,transparent:true,blending:THREE.AdditiveBlending});
  scene.add(new THREE.Points(geo,mat));
})();

function createStarTexture(){
  const size=64,canvas=document.createElement("canvas");
  canvas.width=canvas.height=size;
  const ctx=canvas.getContext("2d");
  const grad=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  grad.addColorStop(0,"rgba(255,255,255,1)");
  grad.addColorStop(0.4,"rgba(255,255,255,0.6)");
  grad.addColorStop(1,"rgba(255,255,255,0)");
  ctx.fillStyle=grad; ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(canvas);
}

function createMilkyWay(){
  const starCount=30000,positions=[],colors=[];
  const arms=4,radius=150,thickness=0.2;
  for(let i=0;i<starCount;i++){
    const r=Math.random()*radius;
    const arm=i%arms;
    const angle=r*0.07+arm*(Math.PI*2/arms);
    const spread=1.5;
    const x=Math.cos(angle)*r+(Math.random()-0.5)*spread;
    const z=Math.sin(angle)*r+(Math.random()-0.5)*spread;
    const y=(Math.random()-0.5)*thickness;
    positions.push(x,y,z);
    const t=r/radius;
    const c=new THREE.Color();
    c.r=1*(1-t)+0.5*t; c.g=0.85*(1-t)+0.8*t; c.b=0.5*(1-t)+1*t;
    colors.push(c.r,c.g,c.b);
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));
  geo.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));
  const mat=new THREE.PointsMaterial({
    size:0.08,map:createStarTexture(),
    transparent:true,opacity:0.9,
    vertexColors:true,blending:THREE.AdditiveBlending,
    depthWrite:false
  });
  const milkyWay=new THREE.Points(geo,mat);
  galaxy.add(milkyWay);
}
createMilkyWay();

// ================= HAND TRACKING =================
const videoEl=document.getElementById("video");
const canvasEl=document.getElementById("handCanvas");
const ctx2=canvasEl.getContext("2d");
let state="ROTATE",smoothState="ROTATE";
const noteEl=document.getElementById("gestureNote");
const stateText={ROTATE:"‚úã Xoay tay: Xoay d·∫£i ng√¢n h√†",PHOTO:"üëå Ch·ª•m tay: Ph√≥ng to h√†nh tinh",HEART:"‚ù§Ô∏è Hai tay h√¨nh tim: K√≠ch ho·∫°t nƒÉng l∆∞·ª£ng",TREE:"‚úä N·∫Øm tay: Thu nh·ªè h·ªá sao"};

const hands=new Hands({locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.7,minTrackingConfidence:0.7});

let lastHandX=null,lastSwipeTime=0,currentPlanetIndex=0,targetCameraPos=new THREE.Vector3();

hands.onResults(results=>{
  ctx2.clearRect(0,0,canvasEl.width,canvasEl.height);
  if(results.image) ctx2.drawImage(results.image,0,0,canvasEl.width,canvasEl.height);
  if(!results.multiHandLandmarks||results.multiHandLandmarks.length===0){state="TREE";return;}

  if(results.multiHandLandmarks.length===2){
    const h1=results.multiHandLandmarks[0],h2=results.multiHandLandmarks[1];
    const dIndex=Math.hypot(h1[8].x-h2[8].x,h1[8].y-h2[8].y);
    const dThumb=Math.hypot(h1[4].x-h2[4].x,h1[4].y-h2[4].y);
    if(dIndex<0.15&&dThumb<0.15){state="HEART";return;}
  }

  const lm=results.multiHandLandmarks[0],wrist=lm[0];
  const tips=[8,12,16,20];
  let open=0; tips.forEach(i=>open+=Math.hypot(lm[i].x-wrist.x,lm[i].y-wrist.y));
  const avgOpen=open/tips.length;
  const pinch=Math.hypot(lm[4].x-lm[8].x,lm[4].y-lm[8].y);
  if(pinch<0.05) state="PHOTO"; else if(avgOpen<0.25) state="TREE"; else state="ROTATE";

  const indexTip=lm[8],now=performance.now();
  if(lastHandX!==null){
    const deltaX=indexTip.x-lastHandX,dt=now-lastSwipeTime;
    if(Math.abs(deltaX)>0.15&&dt>700){
      if(deltaX>0) moveToPlanet(currentPlanetIndex+1); else moveToPlanet(currentPlanetIndex-1);
      lastSwipeTime=now;
    }
  }
  lastHandX=indexTip.x;
});

function moveToPlanet(index){
  if(index<0) index=planets.length-1;
  if(index>=planets.length) index=0;
  currentPlanetIndex=index;
  planets[currentPlanetIndex].userData.planet.getWorldPosition(targetCameraPos);
  targetCameraPos.add(new THREE.Vector3(0,6,14));
}

const cameraMP=new Camera(videoEl,{onFrame:async()=>{await hands.send({image:videoEl});},width:640,height:480});
cameraMP.start();

// ================= ANIMATE =================
const lookTarget=new THREE.Vector3();
const lookTarget = new THREE.Vector3();

function animate() {
  requestAnimationFrame(animate);

  // Xoay m·∫∑t tr·ªùi
  sun.rotation.y += 0.003;

  // Xoay c√°c h√†nh tinh
  planets.forEach(p => {
    p.rotation.y += p.userData.speed;

    // Scale khi PHOTO
    const targetScale = state === "PHOTO" ? 3 : 1;
    p.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
  });

  // CAMERA
  if(state === "ROTATE"){
    // View t·ª´ xa to√†n h·ªá
    targetCameraPos.set(0, 120, 250);
  } else if(state === "PHOTO" || state === "TREE" || state === "HEART") {
    // Camera s·∫Ω ƒë∆∞·ª£c set khi moveToPlanet ƒë∆∞·ª£c g·ªçi
  }

  camera.position.lerp(targetCameraPos, 0.05);

  // Lu√¥n lookAt h√†nh tinh hi·ªán t·∫°i khi zoom
  planets[currentPlanetIndex].userData.planet.getWorldPosition(lookTarget);
  camera.lookAt(lookTarget);

  // Xoay to√†n galaxy khi ROTATE
  if(state === "ROTATE") galaxy.rotation.y += 0.003;

  // Scale galaxy khi HEART
  smoothState = state;
  if(smoothState === "HEART") galaxy.scale.lerp(new THREE.Vector3(1.4,1.4,1.4),0.05);
  else galaxy.scale.lerp(new THREE.Vector3(0.8,0.8,0.8),0.05); // scale ban ƒë·∫ßu nh·ªè h∆°n

  noteEl.textContent = stateText[smoothState] || "";

  renderer.render(scene, camera);
}
animate();

// ================= MOVE CAMERA ƒê·∫æN H√ÄNH TINH =================
function moveToPlanet(index){
  if(index < 0) index = planets.length - 1;
  if(index >= planets.length) index = 0;
  currentPlanetIndex = index;

  const p = planets[currentPlanetIndex].userData.planet;
  p.getWorldPosition(targetCameraPos);
  targetCameraPos.add(new THREE.Vector3(0, 6, 14)); // offset ƒë·ªÉ th·∫•y h√†nh tinh r√µ
}

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
