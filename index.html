<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Galaxy + Solar System</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<style>
#gestureNote {
  position: absolute;
  bottom: 20px;
  left: 20px;
  padding: 10px 14px;
  background: rgba(0,0,0,0.45);
  color: #ffffff;
  font-family: system-ui, -apple-system, BlinkMacSystemFont;
  font-size: 14px;
  border-radius: 12px;
  backdrop-filter: blur(6px);
  pointer-events: none;
  box-shadow: 0 0 12px rgba(255,255,255,0.15);
}
</style>
</head>

<body style="margin:0; overflow:hidden; background:black;">
<video id="video" style="display:none;"></video>
<canvas
  id="handCanvas"
  width="320"
  height="240"
  style="
    position: absolute;
    bottom: 20px;
    right: 20px;
    border-radius: 12px;
    opacity: 0.75;
    pointer-events: none;
    z-index: 10;
  "
></canvas>

<script>
// ================= THREE.JS =================
let currentPlanetIndex = 0;
let targetCameraPos = new THREE.Vector3();
let isSwiping = false;

let lastHandX = null;

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.fov = 45; // nh·ªè h∆°n ‚Üí c·∫£m gi√°c xa h∆°n
camera.updateProjectionMatrix();

camera.position.set(0, 75, 140);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.25));

// ================= GALAXY =================
const galaxy = new THREE.Group();
scene.add(galaxy);

const sunLight = new THREE.PointLight(0xfff2cc, 2.2, 400);
sunLight.position.set(0, 0, 0);
galaxy.add(sunLight);

// Sun
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(6, 32, 32),
  new THREE.MeshStandardMaterial({
    color: 0xffee88,
    emissive: 0xffcc66,
    emissiveIntensity: 1.2
  })
);
galaxy.add(sun);

// ================= PLANETS =================
const planets = [];

function createPlanet(radius, dist, speed, options = {}) {
  const pivot = new THREE.Object3D();

  const material = new THREE.MeshPhysicalMaterial({
    color: options.color,
    roughness: options.roughness ?? 0.6,
    metalness: options.metalness ?? 0.1,
    clearcoat: options.clearcoat ?? 0,
    emissive: options.emissive ?? 0x000000,
    emissiveIntensity: options.emissiveIntensity ?? 0.05
  });

  const planet = new THREE.Mesh(
    new THREE.SphereGeometry(radius, 48, 48),
    material
  );

  planet.position.x = dist;
  pivot.userData.speed = speed;
  pivot.userData.planet = planet;

  pivot.add(planet);
  galaxy.add(pivot);
  planets.push(pivot);

  // üå´ Atmosphere
  if (options.atmosphere) {
    const atmo = new THREE.Mesh(
      new THREE.SphereGeometry(radius * 1.05, 48, 48),
      new THREE.MeshBasicMaterial({
        color: options.atmosphere,
        transparent: true,
        opacity: 0.12,
        blending: THREE.AdditiveBlending
      })
    );
    planet.add(atmo);
    pivot.userData.atmo = atmo;
  }

  // ü™ê Ring
  if (options.ring) {
    const ring = new THREE.Mesh(
      new THREE.RingGeometry(radius * 1.4, radius * 2.2, 64),
      new THREE.MeshBasicMaterial({
        color: options.ring,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
      })
    );
    ring.rotation.x = Math.PI / 2;
    planet.add(ring);
  }

  return pivot;
}

createPlanet(1, 10, 0.02, {
  color: 0xaaaaaa,
  roughness: 0.9
});

createPlanet(1.2, 14, 0.018, {
  color: 0xffcc88,
  emissive: 0xffaa44,
  emissiveIntensity: 0.12
});

createPlanet(1.3, 18, 0.016, {
  color: 0x2266ff,
  roughness: 0.45,
  clearcoat: 0.4,
  atmosphere: 0x66ccff
});

createPlanet(1.1, 22, 0.014, {
  color: 0xff5533,
  roughness: 0.95
});

createPlanet(2.5, 30, 0.01, {
  color: 0xffaa55,
  roughness: 0.6
});

createPlanet(2, 38, 0.008, {
  color: 0xffe0aa,
  roughness: 0.7,
  ring: 0xffddaa
});

createPlanet(1.5, 46, 0.006, {
  color: 0x88ccff,
  emissive: 0x2244ff,
  emissiveIntensity: 0.1
});

function addJupiterBands(planet) {
  const geo = new THREE.SphereGeometry(
    planet.geometry.parameters.radius * 1.001,
    64, 64
  );

  const mat = new THREE.MeshBasicMaterial({
    color: 0xffbb88,
    transparent: true,
    opacity: 0.15
  });

  const bands = new THREE.Mesh(geo, mat);
  planet.add(bands);
}
addJupiterBands(planets[4].userData.planet);

// ================= STAR DUST =================
(function createStars(){
  const count = 6000;
  const pos = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    const r = Math.random() * 80;
    const a = r * 0.35;
    pos[i*3]   = Math.cos(a) * r;
    pos[i*3+1] = (Math.random() - 0.5) * 15;
    pos[i*3+2] = Math.sin(a) * r;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  const mat = new THREE.PointsMaterial({
    size: 1,
    color: 0xffffff,
    opacity: 0.6,
    transparent: true,
    blending: THREE.AdditiveBlending
  });

  scene.add(new THREE.Points(geo, mat));
})();

function createStarTexture() {
  const size = 64;
  const canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext("2d");

  const gradient = ctx.createRadialGradient(
    size/2, size/2, 0,
    size/2, size/2, size/2
  );

  gradient.addColorStop(0, "rgba(255,255,255,1)");
  gradient.addColorStop(0.4, "rgba(255,255,255,0.6)");
  gradient.addColorStop(1, "rgba(255,255,255,0)");

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);

  return new THREE.CanvasTexture(canvas);
}

function createMilkyWay() {
  const starCount = 12000;
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const colors = [];

  const arms = 4;            // s·ªë nh√°nh xo·∫Øn
  const radius = 120;
  const thickness = 0.35;

  for (let i = 0; i < starCount; i++) {
    const r = Math.random() * radius;
    const arm = i % arms;
    const angle = r * 0.08 + arm * (Math.PI * 2 / arms);

    const x = Math.cos(angle) * r + (Math.random() - 0.5) * 3;
    const z = Math.sin(angle) * r + (Math.random() - 0.5) * 3;
    const y = (Math.random() - 0.5) * thickness;

    positions.push(x, y, z);

    const c = new THREE.Color();
    c.setHSL(0.15 + Math.random() * 0.15, 0.7, 0.6);
    colors.push(c.r, c.g, c.b);
  }

  geometry.setAttribute(
    'position',
    new THREE.Float32BufferAttribute(positions, 3)
  );
  geometry.setAttribute(
    'color',
    new THREE.Float32BufferAttribute(colors, 3)
  );

  const material = new THREE.PointsMaterial({
  size: 0.18,
  map: createStarTexture(),
  transparent: true,
  opacity: 0.75,
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
  });

  const milkyWay = new THREE.Points(geometry, material);
  galaxy.add(milkyWay);
}
createMilkyWay();

// ================= HAND TRACKING =================
const videoEl = document.getElementById("video");
const canvasEl = document.getElementById("handCanvas");
const ctx = canvasEl.getContext("2d");

let state = "ROTATE"; // ROTATE | PHOTO | HEART | TREE
let smoothState = "ROTATE";

const noteEl = document.getElementById("gestureNote");

const stateText = {
  ROTATE: "‚úã Xoay tay: Xoay d·∫£i ng√¢n h√†",
  PHOTO: "üëå Ch·ª•m tay: Ph√≥ng to h√†nh tinh",
  HEART: "‚ù§Ô∏è Hai tay h√¨nh tim: K√≠ch ho·∫°t nƒÉng l∆∞·ª£ng",
  TREE: "‚úä N·∫Øm tay: Thu nh·ªè h·ªá sao"
};

const hands = new Hands({
  locateFile: file =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(results => {
  ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

  if (results.image) {
    ctx.drawImage(results.image, 0, 0, canvasEl.width, canvasEl.height);
  }

  if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
    state = "TREE";
    return;
  }

  // ‚ù§Ô∏è Two-hand heart
  if (results.multiHandLandmarks.length === 2) {
    const h1 = results.multiHandLandmarks[0];
    const h2 = results.multiHandLandmarks[1];

    const dIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
    const dThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);

    if (dIndex < 0.15 && dThumb < 0.15) {
      state = "HEART";
      return;
    }
  }

  // ‚úã One-hand gestures
  const lm = results.multiHandLandmarks[0];
  const wrist = lm[0];
  const tips = [8,12,16,20];

  let open = 0;
  tips.forEach(i => {
    open += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y);
  });

  const avgOpen = open / tips.length;
  const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

  if (pinch < 0.05) state = "PHOTO";
  else if (avgOpen < 0.25) state = "TREE";
  else state = "ROTATE";

// ===== VU·ªêT TAY TR√ÅI / PH·∫¢I =====
const indexTip = lm[8]; // ƒë·∫ßu ng√≥n tr·ªè

if (lastHandX !== null) {
  const deltaX = indexTip.x - lastHandX;

  // Vu·ªët ph·∫£i
  if (deltaX > 0.12 && !isSwiping) {
    moveToPlanet(currentPlanetIndex + 1);
    isSwiping = true;
  }

  // Vu·ªët tr√°i
  if (deltaX < -0.12 && !isSwiping) {
    moveToPlanet(currentPlanetIndex - 1);
    isSwiping = true;
  }
}

lastHandX = indexTip.x;
});

// Reset sau khi tay ƒë·ª©ng y√™n
setTimeout(() => {
  isSwiping = false;
}, 400);

// Camera
const cam = new Camera(videoEl, {
  onFrame: async () => await hands.send({ image: videoEl }),
  width: 640,
  height: 480
});
cam.start();

function moveToPlanet(index) {
  if (index < 0) index = planets.length - 1;
  if (index >= planets.length) index = 0;

  currentPlanetIndex = index;

  const planet = planets[index].userData.planet;
  const worldPos = new THREE.Vector3();
  planet.getWorldPosition(worldPos);

  // Camera ƒë·ª©ng l·ªách ch√∫t cho ƒë·∫πp
  targetCameraPos.set(
    worldPos.x + 8,
    worldPos.y + 4,
    worldPos.z + 12
  );
}
// ================= ANIMATE =================
function animate() {
  requestAnimationFrame(animate);

  sun.rotation.y += 0.003;

  planets.forEach(p => {
    p.rotation.y += p.userData.speed;

    const scale = state === "PHOTO" ? 3 : 1;
    p.children[0].scale.lerp(
      new THREE.Vector3(scale, scale, scale), 0.1
    );
  });

  camera.position.lerp(targetCameraPos, 0.05);
camera.lookAt(
  planets[currentPlanetIndex].userData.planet.getWorldPosition(
    new THREE.Vector3()
  )
);

  if (state === "ROTATE") galaxy.rotation.y += 0.003;
  smoothState = state;
  if (smoothState === "HEART") {
  galaxy.scale.lerp(new THREE.Vector3(1.4,1.4,1.4), 0.05);
} else {
  galaxy.scale.lerp(new THREE.Vector3(1,1,1), 0.05);
}
  noteEl.textContent = stateText[smoothState] || "";
  renderer.render(scene, camera);
}
animate();

// ================= RESIZE =================
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
