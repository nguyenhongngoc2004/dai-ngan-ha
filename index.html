<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Universe â€“ 7 Orbits</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(#1a001f, #000000);
  }
  #hint {
    position: fixed;
    bottom: 16px;
    left: 16px;
    color: #fff;
    font-family: system-ui;
    font-size: 14px;
    opacity: 0.6;
  }
</style>
</head>

<body>
<div id="hint">ðŸ–± Drag: Rotate Â· Scroll: Zoom</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

<script>
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  500
);
camera.position.set(0, 10, 32);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;

scene.add(new THREE.AmbientLight(0x222222));
const light = new THREE.PointLight(0xffffff, 2.5, 300);
scene.add(light);

/// ================= GROUP =================
const solar = new THREE.Group();
scene.add(solar);

/// ================= CENTER (small sun) =================
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(1.2, 32, 32),
  new THREE.MeshStandardMaterial({
    emissive: 0xffcc66,
    emissiveIntensity: 1.2,
    color: 0xffee99
  })
);
solar.add(sun);

/// ================= STARS =================
const starGeo = new THREE.BufferGeometry();
const starPos = [];
for (let i = 0; i < 6000; i++) {
  starPos.push(
    (Math.random() - 0.5) * 400,
    (Math.random() - 0.5) * 400,
    (Math.random() - 0.5) * 400
  );
}
starGeo.setAttribute("position", new THREE.Float32BufferAttribute(starPos, 3));
scene.add(new THREE.Points(
  starGeo,
  new THREE.PointsMaterial({ size: 0.35, color: 0xffffff })
));

/// ================= PLANETS =================
const planets = [];

function createOrbit(radius) {
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(radius - 0.04, radius + 0.04, 128),
    new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.35,
      side: THREE.DoubleSide
    })
  );
  ring.rotation.x = Math.PI / 2;
  solar.add(ring);
}

function addPlanet(size, dist, speed, color) {
  createOrbit(dist);
  const pivot = new THREE.Object3D();
  const planet = new THREE.Mesh(
    new THREE.SphereGeometry(size, 32, 32),
    new THREE.MeshStandardMaterial({ color })
  );
  planet.position.x = dist;
  pivot.userData.speed = speed;
  pivot.add(planet);
  solar.add(pivot);
  planets.push(pivot);
}

addPlanet(0.45, 4,  0.03, 0xaaaaaa);
addPlanet(0.65, 6,  0.024, 0xffcc88);
addPlanet(0.75, 8,  0.02, 0x2a5cff);
addPlanet(0.65, 10, 0.018, 0xff5533);
addPlanet(1.15, 14, 0.012, 0xffaa55);
addPlanet(0.95, 18, 0.01, 0xffe0aa);
addPlanet(0.85, 22, 0.008, 0x88ccff);

/// ================= ANIMATE =================
function animate() {
  requestAnimationFrame(animate);
  planets.forEach(p => p.rotation.y += p.userData.speed);
  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>